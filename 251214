### HTTP와 REST API

## HTTP
1. HTTP 요청/응답 메시지 포맷

HTTP는 요청(reqeust) -> 응답(response)로 통신한다.
메시지 구조는 다음 순서로 구성된다.

* Start-Line
* Headers
* 빈줄(필수)
* Body(선택)

1-1. Request 포맷

<Method> <Request-Target> <HTTP-Version>
Header-Name: value
Header-Name: value

(optional body)

ex)
GET /users/123?verbose=true HTTP/1.1
Host: api.example.com
Accept: application/json
Authorization: Bearer <token>

위 예를 해석해보면 아래와 같다.
api.example.com 서버야 내가 인증토큰을 줄테니, ID가 123번인 유저의 정보를 상세하게 JSON 형식으로 줘

좀 더 상세하게 한줄씩 분석해보면 다음과 같다.
[1] Start-Line(시작줄)
GET /users/123?verbose=true HTTP/1.1
- GET (Method) : 데이터 조회
- /users/123 (Path) : users중에 ID가 123인 데이터 조회
- ?verbose=true (Query Parameter) : 옵션추가 verbose(상세정보) -> 자세한 정보 요청
- HTTP/1.1 (version) : HTTP 1.1버전

[2] Header(헤더)
- Host : 요청을 보내는 주소 (HTTP 1.1에서는 필수)
- Accept : 응답은 JSON 형식으로 받음

[3] Authorization: Bearer <token>
- Authorization: Bearer <token> : Bearer : 이 토콘을 가진 사람에게 권한을 달라 라는 뜻의 인증타입이고, <token> 자리에는 실제로 암호화 된 긴 문자열이 들어감.

1-2. Response 포맷

<HTTP-Version> <Status-Code> <Reason-Phrase>
Header-Name: value
Header-Name: value

(optional body)

ex)
HTTP/1.1 200 OK
Content-Type: application/json

{"id":123,"name":"SeungGi"}

위 예시를 해석해보면 아래와 같다.
서버 : 요청대로 처리 완료했어, 데이터 타입은 JSON이고 내용은 승기(SeungGi)라는 유저정보야

좀 더 상세하게 한줄씩 분석해보면 다음과 같다.

[1] Start-Line(Status Line, 상태줄)
HTTP/1.1 200 OK
- HTTP/1.1 (version) : HTTP 1.1 버전
- 200  (Status Code) : 성공
- OK (Reason Phrase) : 문제 없이 처리완료

[2] Headers(헤더)
Content-Type: application/json
- Content-Type: application/json : Body의 데이터형식
- application/json : 텍스트가 아닌 JSON 객체

[3] Empty Line(빈줄)
- 헤더가 끝났음을 의미

[4] Body(본문)
{"id":123, "name":"SeungGi"}
- Payload : 클라이언트가 요청했던 실제 데이터
- JSON : 중괄호와 키:값 으로 이루어져 있어서 자바스크립트나 자바에서 객체로 바로 변환해서 사용할 수 있음

## REST API

1. REST란 무엇인가?
REST는 단순 규칙이 아니라, 웹(HTTP)이 가진 강력한 장점을 제대로 살리기 위해 만든 아키텍처 스타일(설계방식)이다.

핵심 3요소
- 자원(Resource) : 무엇을? (URI)
- 행위(Verb) : 어떻게 할 것인가? (HTTP Method)
- 표현(Representation) : 어떤 모양으로? (JSON, XML)

2. 자원의 표현(URI 설계 원칙)
가장 먼저 API가 건드리는 대상이 무엇인가? 를 주소(URI)로 명확히 해야한다.

rule 1. 동사를 쓰지 않는다.
- (X) GET /getOrders (행위가 주소에 포함됨)
- (O) GET /orders (자원인 '주문'만 명시함)

rule 2. 계층 구조는 /로 표현한다.
- (O) GET /stores/1/menus (1번가게의 -> 메뉴들)

rule 3. 소문자와 명사(주로 복수형)을 사용한다.
- Member 보다는 members, Order보다는 orders를 사용한다.(집합을 의미)

3. 행위(Verb)

3-1. GET(조회)
- 의미 : 서버에서 데이터를 가져온다.
- 특징 : 서버의 데이터를 절대 변경하지 않는다. (Read Only)
- ex) : GET /orders/1 (1번 주문내역 보여줘)

3-2. POST(생성 / 프로세스 처리)
- 의미 : 새로운 리소스를 만들거나, 데이터를 처리한다.
- 특징 : 요청할 때 마다 새로운 데이터가 계속 생긴다.
- ex) : POST /orders (주문서 제출 -> 주문번호 100번 생성, 한번더 보내면 101번 생성)

3-3. PUT(전체수정/ 대체)
- 의미 : 리소스가 있으면 통째로 갈아끼우고, 없으면 생성한다.
- 특징 : 데이터 전체를 보내야하고, 일부를 보내면 나머지는 null이 될 수 있음.
- ex) PUT /members/1

3-4. PATCH(부분 수정)
- 의미 : 리소스의 일부만 고친다.
- 특징 : 실무에서 수정용으로 가장 많이 쓰임.
- ex) PATCH /members/1
  기존 : {"name": "철수", "email": "test@test.com"}
  요청 Body : {"name" : "영희"}
  결과 : {"name" : "영희", "email": "test@test.com"} (이메일은 유지됨)

3-5. DELETE(삭제)
- 의미 : 리소스를 삭제한다.
- ex) DELETE/orders/1 (1번 주문 삭제)

4. 멱등성과 안전성

4-1. 안전성
- GET은 몇번을 조회하더라도 데이터는 바뀌지 않음.
- POST, PUT, PATCH, DELETE는 데이터가 생성되거나 수정, 삭제됨

4-2 멱등성
멱등성은 어떠한 행동을 여러번 하도라도 결과는 같다 라는 뜻이다.
실생활에 있는 예시로 멱등성 예를 들어보겠다.

- 멱등
ex) 엘리베이터 버튼 : 엘리베이터 버튼을 10번을 누르던 1번 누르던 엘리베이터 1대호출은 똑같다.

- 비멱등
ex) 음료수 자판기 버튼 : 자판기에 돈을 넣고 '커피'버튼을 10번을 누르게되면 누르는 횟수만큼 결과가 바뀐다. (1번누르면 커피1잔 10번누르면 커피 10잔)

- GET, PUT, DELETE는 멱등하다
- POST는 위험하다.

POST가 왜 위험한지 예시를 들어보자면 중복결제가 있다.
ex) 사용자가 한 쇼핑몰에서 물건을 구매하기 위하여 10,000원을 결제하였다.
    그러나 인터넷이 느려서 버튼을 따닥(2번) 클릭했다.
    1번째 요청 : POST /payments (Body : 10000원)
    -> 서버 : "결제 승인" 잔액 - 10,000원

    2번쨰 요청 : Post /payments (Body: 10000원)
    -> 서버 : "결제 승인" 잔액 - 10,000원

    결과 -> 사용자는 만원짜리의 한개의 물품을 구매했지만 돈은 20,000원이 빠져나가게 됨(중복결제 현상 발생)

결론 : POST는 기본적으로 멱등하지 않아서 위험하다는 결론이 나오게 된다.

5. REST 아키텍처의 제약조건

5-1. Client-Server 구조
- 클라이언트와 서버가 완전히 분리되어야 한다. 서로 의존하지 않고 각자 개발 가능.

5-2. Stateless(무상태성) * 가장 중요
- 서버는 클라이언트 상태(로그인여부, 이전페이지 등)을 기억하지 않는다.
- 모든 요청은 필요한 정보(토큰 등)를 다 가지고 있어야 한다.

그 이유는 서버 A가 고장나서 서버 B로 요청이 가더라도 처리가 가능하기 때문이다.

5-3. Cacheable (캐시 가능)
- HTTP라는 웹 표준을 쓰기 때문에, 자주 쓰이는 데이터는 브라우저나 CDN 이 캐싱할 수 있어야 한다.

5-4. Uniform Interface (일관된 인터페이스)
- URI는 자원만, Method는 행위만.

## PathVariable vs Query Parameter

1. 위치가 다르다.
ex) http://api.deliverypay.com/users/123?active=true&sort=desc

- ?가 기준선이다.
1-1. PathVariable : ? 앞에 있는 주소의 일부분(/123)
1-2. Query Parameter : ?뒤에 붙는 키=값 쌍 (active=true, sort=desc)

2. PathVariable
- 개념 : 리소스(자원)의 고유한 식별자를 지정할 때 사용한다.
- 특징 : 이 값이 없으면 아예 다른주소가 되거나 404 에러가 나기때문에 필수정보이다.
ex) /orders/100 -> 여기서 100이 PathVariable이다.

Spring에서는 @PathVariable이라는 어노테이션을 쓰고 중괄호 {} 로 위치를 표시한다.
ex) @GetMapping("/orders/{orderId}")

3. Query Parameter
- 개념 : 데이터를 정렬하거나, 필터링하거나, 검색할 때 사용한다.
- 특징 : 이 값은 없더라도 기본 데이터는 조회된다.
- 형식 : ?key=value&key2=value2 (&로 여러 개 연결 가능)
ex) 가게 목록을 보여주는데, 치킨 카테고리만 보고 싶고 최신순으로 정렬해줘
    -> /stores?category=chicken&sort=latest
    여기서 chicken과 latest가 Query Parameter이다.

Spring에서는 @RequestParam이라는 어노테이션을 쓴다.
ex)
@GetMapping("/stores")
public List<Store> getStores(
    @RequestParam String category, // chicken
    @RequestParam String sort      // latest
) {
    return storeService.search(category, sort);
}
