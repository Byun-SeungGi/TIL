# PK와 Clustered Index

PK : 논리적 제약 조건이다.

- 이 테이블에서 각 행을 유일하게 식별할 수 있는 뜻 (ex 주민등록번호)
- 중복이 불가하며, NULL 불가

Clustered Index : 물리적 저장 방식
- 데이터를 디스크에 저장할 때, 이 컬럼을 기준으로 정렬하여 저장하라 라는 뜻 (ex 사전의 가나다순 나열)
- 대부분의 데이터베이스는 PK를 생성하면 자동으로 그 컬럼에 Clustered Index를 생성함
  여기서 오해할 수 있는 부분이 있는데 PK = Clustered Index 뜻은 아님
  엄밀히 말하면 PK를 만들면 DB가 Clustered Index를 생성해준다 라는것이 맞음
  (참고로 MySQL과 MariaDB는 PK 생성이 자동으로 Clustered Index를 생성하지만 Oracle과 Tibero, Postgresql은 자동으로 생성해 주지 않는다.)

PK와 Clustered Index가 결합되었을 때 생기는 장/단점
장점 : PK가 정수형이면서 순차적이라면(auto_increment) 범위검색이 엄청 빠르다
단점 : 만약 PK를 UUID(랜덤값)으로 설정하게 되면  데이터는 정렬되어야 하므로, 중간중간에 데이터를 끼워 넣기 위해 이미 저장된 데이터들을 뒤로 밀어내야하는 페이지 분할이 발생하게 되어 성능이 급격히 떨어지게 됩니다.

Clustered Index와 Non-Clustered Index의 차이
Clustered Index는 사전, Non-Clustered Index는 책으로 비유

Clustered Index(사전)
- PK 순서대로 페이지가 정렬되어 있다.
- 데이터(단어의 뜻)가 인덱스(단어) 바로 옆에 붙어 있다.
- 테이블 당 단 하나만 존재할 수 있음. 왜냐하면 데이터를 두가지 순서로 동시에 정렬할 수 없기 때문

Non-Clustered Index(책)
- 책 뒤편의 '찾아보기'와 같음
- 키워드와 페이지 번호만 있고, 내용은 그 페이지로 직접 찾아가야 볼 수 있음

Clustered Index와 Non-Clustered Index 성능차이

데이터베이스 성능의 핵심은 디스크를 얼마나 적게읽느냐(I/O 최소화)라고 한다.

Clustered Index와 Non-Clustered Index를 이용하여 검색한다고 가정하고 과정을 보자

Clustered Index (PK검색)

SELECT * FROM USER WHERE USER_ID = 100;
이라는 쿼리를 실행했을 경우 과정은 아래와 같다.

1. 인덱스를 탄다.
2. 해당 페이지에 도달한다. (데이터가 바로 거기에 있다면 더이상 이동하지 않는다.)

위 과정처럼 추가적인 이동이 없기때문에 가장 빠르다.

Non-Clustered Index (일반 인덱스 검색)
SELECT * FROM USER WHERE USER_NAME = '홍길동';
이라는 쿼리를 실행했을 경우 과정은 아래와 같다.

1. 이름 인덱스틀 탄다.
2. '홍길동'을 찾는다.
3. 홍길동의 PK가 100번이라는 것을 인지한다.
4. 클러스터드 인덱스로 가서 100번을 찾는다.
5. 데이터를 가져온다.

여기서 LookUp이 발생하여 Clustered Index보다 비용이 더 들게 된다.
LookUp이란 인덱스에서 답을 다 찾지 못하여, 실제 데이터가 있는 곳으로 이동하는 과정을 말한다.


추가적으로 위에서 SELECT * FROM 이라는 쿼리를 사용했다.
하지만 실무에서는 SELECT * 을 쓰지말라고 하는데, 그 이유는 위에서 공부한 내용과 연관이 된다.

내가 정말 필요로하는 컬럼은 정해져있는데 *을 써버리면 불필요한 컬럼까지 모두 가져오려고 하기 때문에, 인덱스에서 처리가 안 끝나고 무조건 LookUp을 하게 만들기 때문이다.






