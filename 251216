## Thread

# 스레드와 프로세스

일단 스레드를 이해하기전에 프로세스와 비교하는게 좋을것 같다.

1. 프로세스(Process) - "실행 중인 프로그램"
우리가 작성한 코드가 실행되어 메모리에 적재된 상태를 프로세스라고 한다.
비유적으로 표현하자면 '식당' 전체 건물에 해당한다.

- 특징 : 각 프로세스는 서로의 기억공간을 침범할 수 없고, 완벽히 격리되어 있다.

2. 스레드(Thread) - "일꾼"
스레드는 프로세스 내에서 실제로 작업을 수행하는 주체이다.
하나의 프로세스 안에는 적어도 하나 이상의 스레드가 존재하게 된다.
비유적으로 표현하자면 식당 안에서 요리하는 요리사이다.

- 특징 : 요리사가 1명이면 싱글스레드, 여러명이면 멀티스레드로 생각하면 된다.

3. 메모리 공유
메모리 공유는 Thread 개념의 핵심이자, Thread-safe 문제의 원인이다.

프로세스(식당)들은 서로 메모리(재료)를 공유하지 않는다.
하지만 같은 프로세스 내의 스레드(요리사)들은 식당의 주방(메모리)를 공유하게 된다.
ex) 냉장고, 가스레인지(Heap, Static 영역)은 모든 요리사가 공동으로 사용한다.
    하지만 각 요리사들은 도마(Stack 영역)은 따로 쓴다.

며칠전에도 Java 메모리 구조와 변수의 위치에 대해서 간략하게 살펴보았지만, 복습은 중요하기 때문에 다시 공부해본다.

- Method Area(Static 영역) : 클래스 변수(static)가 저장되며, 모든 Thread가 공유한다.
- Heap Area : 객체(인스턴스)와 인스턴스 변수가 저장되며, 모든 Thread가 공유한다.
- Stack Area : 메서드 실행시 생성되는 지역변수, 매개 변수가 저장되며 각 Thread 마다 별도로 가진다. (공유하지 않음)

4. 변수 종류별 Thread-safe 관계

4-1. 지역변수 & 매개변수

위치 : Stack 영역(메서드 내부)
안전성 : Thread-safe(항상 안전함)

지역변수와 매개변수가 Thread-safe한 이유는 아래와 같다.
지역변수와 매개변수는 메서드가 실행될 때마다 스레드 별로 할당된 개별적인 Stack 메모리에 생긴다.

아래 예제 코드로 보자.

ex)
public void calculate() {
  int localCount = 0; -> 이 변수를 보면 각 스레드마다 별도의 변수가 생성되었기 때문에 안전하다고 볼 수 있다.
  localCount++;
}

4-2. 인스턴스 변수

위치 : Heap 영역(클래스 내부 or 메서드 밖)
안전성 : Not Thread-safe(위험)

인스턴스 변수는 객체가 생성될 떄 Heap에 만들어진다.
만약 여러 스레드가 하나의 객체를 바라보고 있게 되는 경우, 이 변수를 서로 읽고 쓰려고 경쟁하게 된다. (Race Condition)

아래 예제 코드로 보자.

ex)
public class Counter {
  private int count = 0; -> 인스턴스 변수이며, 여러 스레드가 동시에 접근하게 되면 위험하다.(Not Thread-safe)

  public void addCount() {
    this.count++;
  }
}

4.3. 클래스 변수

위치 : Method Area(Static 영역)
안전성 : Not Thread-safe(위험)

클래스 변수는 프로그램 전체에서 딱 하나만 존재하게 되며, 모든 스레드가 공유한다.
final 상수로 쓰는것이 아니라면 값을 변경할 때 모든 스레드에 영향을 미치기 때문에 동시성 문제가 가장 많이 발생하게 된다.

5. 동시성 문제
동시성 문제란 여러 스레드가 하나의 자원을 동시에 사용하여 서로의 작업을 덮어쓰거나 엉뚱한 값을 읽어버리는 문제이다.

예를 들어보자.

public class CounterService {
    private int count = 0; -> 인스턴스 변수(Heap 영역에 위치하며, 모든 스레드가 공유함)

    public void addCount() {
        // 방문자가 올 때마다 1씩 증가
        this.count++; 
    }
    
    public int getCount() {
        return this.count;
    }
}

위 코드는 방문자가 방문할 때마다 카운트가 1씩 증가하는 예제이다.
두명의 방문자가 방문한다고 가정했을 때 우리는 2명이 방문했으니까 count는 2 라는 결과를 기대하게 된다.

하지만 count++는 3가지 단계를 거쳐 실행이 된다.
1. Read : 현재 count 값을 읽어온다.
2. Modify : 읽어온 값에 1을 더한다.
3. Write : 더한 값을 다시 count 변수에 저장한다.

이러한 과정을 통해 count++ 가 실행이 되는데 만약 동시에 0.1초의 오차도 없이 두명의 방문자가 동시에 방문하게 되면 어떻게 될까?

1. Read : 짱구(스레드 A) : 메모리에서 count를 읽는다. (현재 count 값은 0)
          동시에 맹구(스레드 B) : 메모리에서 count를 읽는다. (현재 count 값은 0)

2. Modify : 짱구 : 가져온 0에 1을 더한다. (결과값은 1)
            맹구 : 가져온 0에 1을 더한다. (결과값은 1)

3. Write : 짱구 : 계산한 1을 count에 저장한다. (현재 count 값은 1)
           맹구 : 계산한 1을 count에 덮어씌운다. (현재 count 값은 1)

이렇게 되면 실제 방문자수는 2명인데 저장된 count는 1이 되버린다.

이 문제가 바로 동시성 문제이다.

5.1 동시성 문제를 해결하는 방법
- 지역 변수 사용하기
- 동기화(Synchronization) 사용하기
  꼭 공유를 한다면 짱구가 count를 사용하는 동안에는 맹구가 count에 접근하지 못하도록 Lock을 거는 방법이 있다.
  ex) synchronized, CouncurrentHashMap, AtomicIntger등 (이 3가지 방법에 대해서는 추후에 다시 공부하고 기록해야겠다.)

